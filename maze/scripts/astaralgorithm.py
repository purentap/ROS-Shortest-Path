#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""AStarAlgorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GNnmMEvkbXjBztQ6UaWIiZs-Oa-0ENkN
"""

from __future__ import print_function
import heapq
import math
import rospy
import sys
import numpy as np
import time
import Tkinter as tkinter
from maze.msg import MazeMessage as MData

#tkinter object for visualization
scale = 8
root = tkinter.Tk()
root.title = "Path"
container = tkinter.Frame(root)
container.pack()
canvas = tkinter.Canvas(container, width = 800, height = 900, borderwidth=0, highlightthickness=0, bg ="khaki")
canvas.pack()



def print_maze(maze):
  height = len(maze)
  width = len(maze[0])
  for i in range(0,height):
    for j in range(0,width):
      print(maze[i][j],end= " ")
    print("\n")



row = 100
col = 100




class Node():
  def __init__(self, parentPos=None, position=None):
    self.parentPos = parentPos
    self.position = position
    self.g = 0
    self.h = 0
    self.f = 0


def isValid(pos,row,col): #checks if the given row and column is on the maze
  return pos[0]>= 0 and pos[0]< row and pos[1]>= 0 and pos[1]< col

def isUnblocked(maze, pos): #returns true if the given position is a path
  if maze[pos[0]][pos[1]] == 1 :
    return True
  else:
    return False


def calculateHval(position, goal): #used Manhattan Distance
  res = abs(position[0] - goal.position[0]) + abs(position[1] - goal.position[1])
  return res

def visualize_maze(maze):
  #global canvas
  canvas.delete("all")
  for i in range(row):
    for j in range(col):
        if maze[i][j] == 1:
            c_id = canvas.create_rectangle((j*scale) ,i*scale ,((j+1)*scale), (i+1)*scale,  fill="SteelBlue4", outline = 'SteelBlue4', width= 2)
  return canvas

def tracePath(closedList,cellDetails, goal):

  #global canvas
  stack = []
  destination = goal.position
  stack.append(destination)
  parentLocation = cellDetails[destination[0]][destination[1]].parentPos
  while parentLocation != None : 
    stack.append(parentLocation)
    parentLocation =  cellDetails[parentLocation[0]][parentLocation[1]].parentPos
   
  for i in range(len(stack)):
    cord = stack[i]
    if i == 0 or i == len(stack)-1:
      c_id = canvas.create_oval(cord[1]*scale , cord[0]*scale, (cord[1]+1)*scale, (cord[0] +1)*scale, fill = 'orange red', outline = "orange red", width = 4  )
    if i != len(stack)-1:
      cord = stack[i]
      second_cord = stack[i+1]
      c_id = canvas.create_line(cord[1]*scale + scale/2, cord[0]*scale +scale/2 , second_cord[1]*scale + scale/2, second_cord[0]*scale + scale/2, fill = 'red', width = 3  )
  
  while len(stack)!= 0 :
    print(stack.pop())
 
def aStarSearchAlgorithm(data):
  #global canvas
  start = time.time()
 
  openList = []
  closedList = {}
  cellDetails = [[None] * col for i in range(row)] #to check if the cell is in open list, and stores it's f value
  rospy.loginfo(rospy.get_caller_id() + "heard the maze generator. A* search will run")
  maze= data.maze
  maze = np.reshape(maze,(-1,col))
  #print_maze(maze)
  canvas_ = visualize_maze(maze)
  source = Node(None, list(data.startLocation))
  goal = Node(None, list(data.endLocation))
  print("exit: ", goal.position)
  print("entrance:" , source.position)
  
  heapq.heappush(openList, (source.f, source.position))

  cellDetails[source.position[0]][source.position[1]] = source

  Found = False
  while len(openList)>0 :
    cell = heapq.heappop(openList)
    pos = cell[1]
    closedList[pos[0], pos[1]] = True

    #check 4 neighbours of the cell
    neighbours = [[1,0], [0,1], [-1,0], [0,-1]] # [1,1], [-1,-1], [1,-1], [-1,1]] 
    for i in neighbours:
      newPos = [pos[0] + i[0] , pos[1]+ i[1]]
      #print(newPos) 
      if newPos == goal.position : 
        
        newNode = Node(pos, newPos)
        cellDetails[newPos[0]][newPos[1]] = newNode
        closedList[newPos[0], newPos[1]] = True
        print("\nPath is found:")
        Found = True
        tracePath(closedList, cellDetails, goal)


      elif isValid(newPos,row,col) and isUnblocked(maze, newPos) and (newPos[0], newPos[1]) not in closedList :
        if i == [1,0] or i == [0,1] or i == [-1,0] or i == [0,-1] : 
          gNew = cellDetails[pos[0]][pos[1]].g + 1
        else:
          gNew = cellDetails[pos[0]][pos[1]].g + 1.414

        hNew = calculateHval(newPos, goal)
        fNew = gNew + hNew
        cellVal = cellDetails[newPos[0]][newPos[1]]
        if cellVal == None or cellVal.f > fNew : 
          newNode = Node(pos, newPos)
          newNode.g = gNew
          newNode.h = hNew
          newNode.f = fNew
          cellDetails[newPos[0]][newPos[1]] = newNode
          heapq.heappush(openList, (newNode.f, newNode.position))

  if Found == False: 
    print("Path cannot be found")

  end = time.time()
  total_time = end - start
  
  output = 'Map Size: ' , row,"x",col, '- Solved in: ', total_time, ' seconds'
  canvas.create_text( (col/2)*scale, row*scale, text = output ) 
  

  
def PathFinder():
  
  rospy.init_node("PathFinderN",anonymous=True )
  rospy.Subscriber("PathFinderTopic", MData, aStarSearchAlgorithm)
  #rospy.spin()
  root.mainloop()
  
if __name__ == '__main__':

  PathFinder()
  
