#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""mazeGenerator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VsHpkyOSW0rAso2scz_c10lzP6QNE9oq
"""


from __future__ import print_function
import rospy
import numpy as np
import random
import sys
from std_msgs.msg import String
from maze.msg import MazeMessage as MData


def create_maze(width, height):
  maze = []
  for i in range(0,height):
    row=[]
    for j in range(0,width):
      row.append("u")
    maze.append(row)
  return maze

def print_maze(maze):
  height = len(maze)
  width = len(maze[0])
  for i in range(0,height):
    for j in range(0,width):
      #sys.stdout.write(maze[i][j])
      print(maze[i][j], end = " ")
    print("\n")



def check_neighbours(random_wall, maze):
  numPath = 0
  row = random_wall[0]
  col = random_wall[1]
  if maze[row+1][col] == "p":
    numPath+=1
  if maze[row][col+1] == "p":
    numPath+=1
  if maze[row-1][col] == "p":
    numPath+=1
  if maze[row][col-1] == "p":
    numPath+=1
  return numPath

def delete_wall(walls, random_wall): #hash tables in python?
  for wall in walls:
    if wall[0] == random_wall[0] and wall[1] == random_wall[1]:
      walls.remove(wall)

#print_maze(maze)

def random_maze(data):
  rospy.loginfo(rospy.get_caller_id() + "heard the publisher, new maze will be generated")
  row = 100
  col = 100
  maze= create_maze(row,col)
  walls = []
  #random cell in the maze (initally "u")
  starting_row = int(random.randint(0,row-1))
  starting_col = int(random.randint(0, col-1))

  #edge cases for random index generation
  if starting_row == 0:
    starting_row +=1 
  if starting_col == 0:
    starting_col += 1 
  if starting_row == row-1: 
    starting_row -=1
  if starting_col == col-1:
    starting_col -=1

  #mark the random unvisited cell as path
  #mark the cells around the path as walls
  maze[starting_row][starting_col] = "p"
  maze[starting_row-1][starting_col] = "w"
  maze[starting_row][starting_col-1] = "w"
  maze[starting_row+1][starting_col] = "w"
  maze[starting_row][starting_col+1] = "w"

  walls.append([starting_row-1, starting_col])
  walls.append([starting_row, starting_col-1])
  walls.append([starting_row+1, starting_col])
  walls.append([starting_row, starting_col+1])



  while (len(walls)!= 0):
    random_wall = walls[random.randint(0, len(walls) -1)]
    delete_wall(walls,random_wall)
    wall_row = random_wall[0]
    wall_col = random_wall[1]
    if wall_row != 0 and wall_row != row-1: #edges
      if (maze[wall_row-1][wall_col] == 'u' and maze[wall_row+1][wall_col] == 'p') or (maze[wall_row-1][wall_col] == "p" and maze[wall_row+1][wall_col] == "u"):
        surrCells = check_neighbours(random_wall, maze)
        #delete_wall(walls,random_wall)
        if surrCells < 2 :
          maze[wall_row][wall_col] = "p"
          if wall_col != 0 :
            if maze[wall_row][wall_col-1] != "p" and [wall_row, wall_col-1] not in walls: 
              maze[wall_row][wall_col-1] = "w"
              walls.append([wall_row,wall_col-1])
          if wall_col != col-1: 
            if maze[wall_row][wall_col+1] != "p" and [wall_row, wall_col+1] not in walls: 
              maze[wall_row][wall_col+1] = "w"
              walls.append([wall_row,wall_col+1])
          if maze[wall_row+1][wall_col] != "p" and [wall_row+1, wall_col] not in walls: 
            maze[wall_row+1][wall_col] = "w"
            walls.append([wall_row+1, wall_col])
          if maze[wall_row-1][wall_col] != "p" and [wall_row-1, wall_col] not in walls:
            maze[wall_row+-1][wall_col] = "w"
            walls.append([wall_row-1, wall_col])
    if wall_col != 0 and wall_col != col-1: #edges
      if (maze[wall_row][wall_col-1] == "u" and maze[wall_row][wall_col+1] == "p" ) or (maze[wall_row][wall_col-1] == "p" and maze[wall_row][wall_col+1] == "u"):
        surrCells = check_neighbours(random_wall, maze)
        #delete_wall(walls,random_wall)
        if surrCells < 2 :
          maze[wall_row][wall_col] = "p"
          if wall_row != 0 :
            if maze[wall_row-1][wall_col] != "p":
              if [wall_row-1,wall_col] not in walls:
                  maze[wall_row-1][wall_col] = "w"
                  walls.append([wall_row-1,wall_col])
          if wall_row != row-1:
            if maze[wall_row+1][wall_col] != "p" :
              if [wall_row+1, wall_col] not in walls:
                maze[wall_row+1][wall_col] = "w"
                walls.append([wall_row+1,wall_col])
          if maze[wall_row][wall_col-1] != "p" and [wall_row, wall_col-1] not in walls: 
              maze[wall_row][wall_col-1] = "w"
              walls.append([wall_row,wall_col-1])
          if maze[wall_row][wall_col+1] != "p" and [wall_row, wall_col+1] not in walls: 
            maze[wall_row][wall_col+1] = "w"
            walls.append([wall_row,wall_col+1])


  ##GENERATE AN ENTRANCE AND AN EXIT 
  #######need randomness here, use while loop and randint, give conditions accordingly.
  for i in range(0, col):
      if (maze[1][i] == 'p'):
          maze[0][i] = 'p'
          entrance = [0,i]
          break
      
  for j in range(col-1, 0, -1):
    if (maze[row-2][j] == 'p'):
      maze[row-1][j] = 'p'
      exit = [row-1,j]
      break
  

  #FILL THE UNVISITED CELLS WITH WALLS
  for i in range(0,row):
    for j in range(0,col):
      if maze[i][j]== "u":
        maze[i][j] = "w"
  #print(row,col)
  #print_maze(maze)
  #Make walls 1 and paths 0 -> can be done while generating the maze 
  #import matplotlib.pyplot as plt
  row = 100
  col = 100

  for i in range(0,row):
    for j in range(0,col):
      if maze[i][j] == "w":
         maze[i][j] = 0
      else:
        maze[i][j] = 1
  print_maze(maze)
  maze = np.array(maze)
  maze = maze.flatten()
  MazeData = MData()
  MazeData.maze = maze
  MazeData.startLocation = entrance
  MazeData.endLocation = exit
  pub = rospy.Publisher("PathFinderTopic", MData, queue_size = 10)
  message = "New maze is generated, sending it to the A* Algorithm"
  rospy.loginfo(message)
  pub.publish(MazeData)

'''
plt.figure(figsize=(10, 10))
plt.xticks([]) 
plt.yticks([]) 
plt.axes().invert_yaxis() #invert the y-axis so the first row of data is at the top
plt.spy(maze, precision = 0.1, markersize = 5)
'''
def maze():
  rospy.init_node("maze_generator",anonymous=True )
  rospy.Subscriber("keystroke", String, random_maze)


  rospy.spin()

if __name__ == '__main__':
  maze()

